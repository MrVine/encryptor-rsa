package main

import (
	rsa "github.com/mrvine/encryptor-rsa"
	"log"
)

func verySimpleExplanation() {
	plain := "Plain text"

	// ----------------- SIDE #1 ------------------

	// Initialize encryptor1
	encryptor1, _ := rsa.Init(rsa.DefaultKeyLength)

	// Retrieve public key to send it to SIDE #2
	publicKey, _ := encryptor1.GetPublicKeyAsPEM()

	// Retrieve private key to save it locally
	privateKey, _ := encryptor1.GetPrivateKeyAsPem()

	// Suppose that in this point
	// public key is transmitted over internet
	// or by any other way

	// --------------------------------------------



	// ----------------- SIDE #2 ------------------

	// Initialize encryptor2 as Empty RsaEncryptor,
	// to avoid keys generation
	encryptor2 := rsa.InitEmpty()

	// Set public key, generated by encryptor1
	// to encryptor2.PublicKey
	encryptor2.SetPublicKeyFromPEM(publicKey)

	// Encrypt plain data by encryptor2
	encrypted, _ := encryptor2.Encrypt(plain)

	// suppose that in this point
	// encrypted data is transmitted over
	// internet or by any other way

	// --------------------------------------------



	// ----------------- SIDE #2 ------------------

	// Initialize decryptor as Empty RsaEncryptor,
	// to avoid keys generation
	decryptor := rsa.InitEmpty()

	// Loading previously saved private key
	decryptor.SetPrivateKeyFromPEM(privateKey)

	// Decrypting message
	decrypted, _ := decryptor.Decrypt(encrypted)

	// --------------------------------------------



	if plain == decrypted {
		log.Println("DECRYPTED MESSAGE IS EQUALS TO PLAIN MESSAGE")
	} else {
		log.Println("SOMETHING GOES WRONG")
	}
}

func main() {

	verySimpleExplanation()

	//args, err := getArgs()
	//if err != nil {
	//	log.Fatal("args parsing error:", err)
	//}
	//
	//e, err := rsa.Init(args.KeyLength)
	//if err != nil {
	//	log.Fatal(err)
	//}
	//
	//result, err := e.Execute(args.Command, args.Message)
	//if err != nil {
	//	log.Fatal(err)
	//}
	//
	//log.Printf("%sion is finished successfully", args.Command)
	//log.Printf("    input:            %s", args.Message)
	//log.Printf("    output:           %s", result)
	//log.Printf("    public key path:  %s", args.PublicKeyPath)
	//log.Printf("    private key path: %s", args.PrivateKeyPath)
	//
	//plainText := "This is a test string for RSA :)"
	//log.Println("plain text:", plainText)
	//
	//encrypted, err := e.Encrypt(plainText)
	//if err != nil {
	//	log.Fatal("can not encrypt:", err)
	//}
	//log.Println("encrypted:", encrypted)
	//
	//decrypted, err := e.Decrypt(encrypted)
	//if err != nil {
	//	log.Fatal("can not decrypt:", err)
	//}
	//log.Println("decrypted:", decrypted)
	//
	//privateKeyPEM := e.GetPrivateKeyAsPem()
	//publicKeyPEM, err := e.GetPublicKeyAsPEM()
	//if err != nil {
	//	log.Fatal("Can't convert public-key to PEM-formatted string")
	//}
	//
	//e = rsa.InitEmpty()
	//
	//e.SetPublicKeyFromPEM(publicKeyPEM)
	//encrypted2, _ := e.Encrypt(plainText)
	//
	//fmt.Printf("%30s: %s", "Plain text", plainText)
	//fmt.Printf("%30s: %s", "Encrypted text", encrypted)
	//
	//e.SetPrivateKeyFromPEM(privateKeyPEM)
	//decrypted2, _ := e.Decrypt(encrypted2)
	//
	//fmt.Printf("%30s: %s", "Decrypted text", decrypted2)
}
